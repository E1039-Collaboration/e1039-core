15,17d14
< 
< #include <phool/recoConsts.h>
< 
21a19,22
> #include "KalmanFastTracking.h"
> #include "TriggerRoad.h"
> #include "GeomSvc.h"
> #include "JobOptsSvc.h"
25a27
> 
28c30
< KJob::KJob(int jobId, SRawEvent* evPtr): jobId(jobId){
---
> KJob::KJob(int jobId, SRawEvent* evPtr, KScheduler* universe): jobId(jobId),universe(universe){
33,34d34
<     // doubt that the mutex here is helpful even if EnableThreadSafety works as
<     // advertised... but maybe for a bad malloc? better to take later if needed
36d35
<     jobMutex->Lock();
39,40d37
<     // dont think ev are so big but it could fail to allocate
<     // copy the event Data:
51d47
<     jobMutex->UnLock();
52a49,58
> 
>     // get an available, clean TClonesArr
>     universe->ktrkqFSem->Wait();
>     universe->ktrkQueueMutex->Lock();
>     tracklets = universe->kTrackArrQueue.front();
>     universe->kTrackArrQueue.pop();
>     universe->ktrkQueueMutex->UnLock();
>     universe->ktrkqESem->Post();
>     nTracklets = 0;
> 
55a62
> 
62a70,81
> /*
> KJob::clear(){
>     evData->clear();
>     recEvData->clear();
>     if(LOUD){
>         TThread::Printf("Kjob: %i completed in time:\n",jobId);
>         jobTimer->Print("u");
>     }
>     jobTimer->Reset();
>     tracklets->Clear("C");
> }
> */
78a98,105
>     // clear and yield tracklet array
>     // TODO check if "C" needed in arg for tracklets
>     tracklets->Clear();
>     universe->ktrkqESem->Wait();
>     universe->ktrkQueueMutex->Lock();
>     universe->kTrackArrQueue.push(tracklets);
>     universe->ktrkQueueMutex->UnLock();
>     universe->ktrkqFSem->Post();
96,97c123
< 
< //TODO Output
---
> int KScheduler::trackletStationId=0;
101c127
< KScheduler::KScheduler(TString inFile, TString outFile) 
---
> KScheduler::KScheduler(TString options) 
111c137
<     recoConsts* rc = recoConsts::instance();
---
>     JobOptsSvc* p_jobOptsSvc = JobOptsSvc::instance(); 
113,119c139,141
<     // // I/O managed by fReader and fReaper
<     // No longer using the pJobOptsSvc...
<     // this->setInputFilename( p_jobOptsSvc->m_inputFile );
<     // this->setOutputFilename( p_jobOptsSvc->m_outputFile );
<     // take as args
<     this->setInputFilename(inFile)
<     this->setOutputFilename(outFile)
---
>     // I/O managed by fReader and fReaper
>     this->setInputFilename( p_jobOptsSvc->m_inputFile );
>     this->setOutputFilename( p_jobOptsSvc->m_outputFile );
121a144,151
>     TString opt = "aoc";      //turn on after pulse removal, out of time removal, and cluster removal
>     if(p_jobOptsSvc->m_enableTriggerMask) opt = opt + "t";
>     if(p_jobOptsSvc->m_sagittaReducer) opt = opt + "s";
>     if(p_jobOptsSvc->m_updateAlignment) opt = opt + "e";
>     if(p_jobOptsSvc->m_hodomask) opt = opt + "h";
>     if(p_jobOptsSvc->m_mergeHodo) opt = opt + "m";
>     if(p_jobOptsSvc->m_realization) opt = opt + "r";
> 
124c154
<         eventReducer = new EventReducer(rc->get_CharFlag("EventReduceOpts"));
---
>         eventReducer = new EventReducer(opt);
139,141c169
<         // TODO when _ENABLE_KF KFT takes a PHField* and TGeoManager* as args
<         // only used with the KalmanFitter which can be added later...
<         kFastTracker = new KalmanFastTracking(nullptr, nullptr, false);
---
>         kFastTracker = new KalmanFastTracking();
145a174,181
>     // build TClonesArrays for tracklet outputs
>     TClonesArray* trackletArray = 0;
>     for(i=0; i<NTHREADS; i++){
>         trackletArray= new TClonesArray("Tracklet",1000);
>         trackletArray->BypassStreamer();
>         assert(trackletArray);
>         kTrackArrQueue.push(trackletArray);
>     }
174a211,213
> 
>     //tracklet arr
>     ktrkQueueMutex = new TMutex();
187a227,230
>     // trackletArrays
>     ktrkqFSem = new TSemaphore(NTHREADS);
>     ktrkqESem = new TSemaphore(0);
> 
270a314,321
>     TClonesArray* trkArr= 0;
>     for(i=0; i<NTHREADS; i++){
>         trkArr = kTrackArrQueue.front();
>         assert(trkArr);
>         kTrackArrQueue.pop();
>         delete trkArr;
>     }
> 
273a325,327
> 
>     //tracklet arr mutex
>     delete ktrkQueueMutex;
286a341,344
>     // tracklet arrays sems
>     delete ktrkqFSem;
>     delete ktrkqESem;
> 
416a475,479
> 
> void KScheduler::getTrackletsInStation(int stid){
>     trackletStationId = stid; 
> }
> 
428a492,493
>         TThread::Printf("\n");
> 
479c544
<         newKJobPtr = new KJob(i,localEventPtr);
---
>         newKJobPtr = new KJob(i,localEventPtr,kschd);
511c576
<     recoConsts* rc = recoConsts::instance();
---
>     JobOptsSvc* jobOptsSvc = JobOptsSvc::instance();
514a580,581
>     int nTracklets = 0;
>     int sizeTrackArr = 0;
522a590
>     TClonesArray* outputTracklets = new TClonesArray("Tracklet",1000);
526a595
>     jobOptsSvc->save(saveFile);
531,532c600,602
<     //saveTree->Branch("nTracklets", &nTracklets, "nTracklets/I");
< //    saveTree->Branch("tracklets", &tracklets, 256000, 99);
---
>     saveTree->Branch("outputTracklets", &outputTracklets, 256000, 99);
>     saveTree->Branch("nTracklets", &nTracklets, "nTracklets/I");
>     saveTree->Branch("sizeTrackArr", &sizeTrackArr, "nTracklets/I");
587a658,680
>         //outputTracklets = tCompleteJobPtr->tracklets;
> 
>         //outputTracklets = new TClonesArray(*(tCompleteJobPtr->tracklets));
>         *outputTracklets = *(tCompleteJobPtr->tracklets);
> 
>         TClonesArray& ref_output = *outputTracklets;
>         nTracklets = tCompleteJobPtr->nTracklets;
>         sizeTrackArr = outputTracklets->GetEntries();
>         assert(outputRawEventPtr);
>         assert(outputRecEventPtr);
>         assert(outputTracklets);
>         if(LOUD){
>             TThread::Printf("got tracklets: %i for disk for event: %i\n",outputTracklets->GetEntries(), 
>                 tCompleteJobPtr->evData->getEventID());
>             TThread::Printf("outputTracklets pointer is: %p\n", outputTracklets);
>         
>             if(outputTracklets->GetEntries()>0){
>                 Tracklet* printer = (Tracklet*) ref_output[0];
>                 TThread::Printf("first tracklet for disk is%p\n",printer);
>                 if(printer)
>                     printer->print();
>             }
>        }
590c683
<             TThread::Printf("fReaper saving another %i jobs\n", SAVENUM);
---
>             TThread::Printf("fReaper saving another %i jobs", SAVENUM);
593c686,687
<         
---
>         outputTracklets->Clear();
>         // need to reuse these job objects because tracklets are large...
596d689
<     
608,609d700
< //    assert(tracklets);
< //    delete tracklets;
610a702
>     // outputTracklets? do i need to delete shallow copy?
646c738
<     recoConsts* rc = recoConsts::instance();
---
>     JobOptsSvc* jobOptsSvc = JobOptsSvc::instance();
660,663c752,753
< //   TClonesArray* tracklets = new TClonesArray("Tracklet");
< //    TClonesArray& arr_tracklets = *tracklets;
< 
< 
---
> //    std::list<Tracklet>& rec_tracklets = NULL;
> //    TClonesArray& arr_tracklets = NULL;
750a841,842
>         if(recStatus == 0)
>             TThread::Printf("kFastTrackRecStatus: %i",recStatus);
761,790d852
<         //arr_tracklets.Clear();
< 
<         std::list<Tracklet>& rec_tracklets = kFastTracker->getFinalTracklets(); 
< /*        if(rec_tracklets.empty()){
<             TThread::Printf("Worker %u no tracklets in event: %i\n",
<                 threadId, tCompleteJobPtr->evData->getEventID());
< 
< 
<             //TODO next event more gracefully without all this repeated code
<             // bail and go for next event...
<             // put tracker back in queue...
<             
<             tCompleteJobPtr->jobMutex->Lock();
<             tCompleteJobPtr->p_JobStatus = HALTED;
<             tCompleteJobPtr->jobMutex->UnLock();
< 
<             kschd->kftqESem->Wait();
<             kschd->kFTrkQueuePutMutex->Lock();
<             kschd->kFastTrkQueue.push(kFastTracker);
<             kschd->kFTrkQueuePutMutex->UnLock();
<             kschd->kftqFSem->Post();
< 
<             //put job in complete queue
<             kschd->cjqESem->Wait();
<             kschd->cmpJobQueuePutMutex->Lock();
<             kschd->cmpJobQueue.push(tCompleteJobPtr);
<             kschd->cmpJobQueuePutMutex->UnLock();
<             kschd->cjqFSem->Post();
< 
<             continue;
791a854,859
> //        std::list<Tracklet>& rec_tracklets = kFastTracker->getFinalTracklets(); 
>         std::list<Tracklet>& rec_tracklets = kFastTracker->getTrackletList(kschd->trackletStationId);
>         TClonesArray& arr_tracklets = *(tCompleteJobPtr->tracklets);
>         if(LOUD){
>             TThread::Printf("job pointer for tracklets is%p\n",tCompleteJobPtr->tracklets);
>             TThread::Printf("trackletsize:%i\n",tCompleteJobPtr->tracklets->GetEntries());
793c861
< */
---
> 
796d863
< 
798,800c865,870
<         for(std::list<Tracklet>::iterator iter = rec_tracklets.begin(); iter != rec_tracklets.end(); ++iter)
<         {
<             //iter->print();
---
>         Tracklet* printer = 0;
> 
> 
> 
> /*
>         for(std::list<Tracklet>::iterator iter = rec_tracklets.begin(); iter != rec_tracklets.end(); ++iter){
804c874,875
<             //new(arr_tracklets[nTracklets++]) Tracklet(*iter);
---
>             new(arr_tracklets[nTracklets++]) Tracklet(*iter);
>             TThread::Printf("iterating through tracklet: %p",iter);
812a884
> 
816,829c888,913
< 
<         // if(jobOptsSvc->m_enableEvaluation){
<         //     for(int j = 3; j!=0; --j){
<         //         std::list<Tracklet>& tracklets_temp = kFastTracker->getTrackletList(j);
<         //         for(std::list<Tracklet>::iterator iter = tracklets_temp.begin(); iter != tracklets_temp.end(); ++iter){
<         //             iter->calcChisq();
< 
<         //             //TODO tracklets
<         //             //new(arr_tracklets[nTracklets]) Tracklet(*iter);
<         //             tCompleteJobPtr->nTracklets++;
<         //         }
<         //     }
<         // }
< 
---
> */
>         if(jobOptsSvc->m_enableEvaluation){
>             for(int j = 3; j!=0; --j){
>                 std::list<Tracklet>& tracklets_temp = kFastTracker->getTrackletList(j);
>                 for(std::list<Tracklet>::iterator iter = tracklets_temp.begin(); iter != tracklets_temp.end(); ++iter){
>                     
> //                    TThread::Printf("evaluating tracklets");
>                     iter->calcChisq();
> //                    iter->print();
> 
>                     //TODO tracklets
>                     new(arr_tracklets[nTracklets++]) Tracklet(*iter);
>                     tCompleteJobPtr->nTracklets++;
>                 }
>             }
>             if(LOUD){
>                 TThread::Printf("arr_tracklet has %i entries for eventID: %i\n",arr_tracklets.GetEntries(), 
>                     tCompleteJobPtr->evData->getEventID());
>                 if(arr_tracklets.GetEntries() > 0){
>                     printer = (Tracklet*) arr_tracklets[0]; 
>                     TThread::Printf("first tracklet is:%p for eventID: %i\n",printer, tCompleteJobPtr->evData->getEventID());
>                     if(printer)
>                         printer->print();
>                 }
>            }
>         }
849d932
< 
